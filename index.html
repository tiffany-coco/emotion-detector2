<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æƒ…ç»ªè¯†åˆ«å°åŠ©æ‰‹ - ç‰¹æ®Šæ•™è‚²æ•™å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Comic Sans MS', 'å¾®è½¯é›…é»‘', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #4a4a4a;
            font-size: 2em;
            margin-bottom: 10px;
        }

        /* æ¸¸æˆé€‰æ‹© */
        .game-selection {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .game-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 20px;
            border-radius: 15px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .game-btn:hover {
            background: #45a049;
            transform: translateY(-3px);
        }

        /* æ¸¸æˆåŒºåŸŸ */
        .game-area {
            text-align: center;
            margin: 30px 0;
            min-height: 300px;
        }

        .target {
            background: #ff6b6b;
            color: white;
            padding: 15px 30px;
            border-radius: 15px;
            font-size: 1.5em;
            margin: 20px 0;
            display: inline-block;
        }

        .emoji-large {
            font-size: 80px;
            margin: 20px 0;
        }

        .options {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin: 30px 0;
        }

        .option {
            background: white;
            border: 3px solid #4CAF50;
            border-radius: 15px;
            padding: 15px 25px;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 120px;
        }

        .option:hover {
            background: #4CAF50;
            color: white;
            transform: scale(1.05);
        }

        /* æ§åˆ¶æŒ‰é’® */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        .btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
        }

        .btn:hover {
            background: #1976D2;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #4CAF50;
        }

        .btn-danger {
            background: #f44336;
        }

        /* ç»“æœåé¦ˆ */
        .feedback {
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 1.2em;
            display: none;
        }

        .success {
            background: #d4edda;
            color: #155724;
            border: 2px solid #c3e6cb;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border: 2px solid #f5c6cb;
        }

        .score {
            background: #fff3cd;
            padding: 15px;
            border-radius: 10px;
            margin: 20px auto;
            max-width: 200px;
            font-size: 1.5em;
            font-weight: bold;
        }

        @media (max-width: 600px) {
            .game-selection {
                grid-template-columns: 1fr;
            }
            
            .options {
                flex-direction: column;
                align-items: center;
            }
            
            .option {
                width: 100%;
                max-width: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ­ æƒ…ç»ªè¯†åˆ«å°åŠ©æ‰‹</h1>
            <p>ç‰¹æ®Šæ•™è‚²äº’åŠ¨æ•™å­¦å·¥å…·</p>
        </div>

        <!-- æ¸¸æˆé€‰æ‹© -->
        <div class="game-selection">
            <button class="game-btn" onclick="startGame('identification')">æƒ…ç»ªæŒ‡è®¤æ¸¸æˆ</button>
            <button class="game-btn" onclick="startGame('matching')">æƒ…ç»ªé…å¯¹æ¸¸æˆ</button>
            <button class="game-btn" onclick="startGame('situation')">æƒ…å¢ƒé…å¯¹æ¸¸æˆ</button>
            <button class="game-btn" onclick="startGame('eliminate')">æ¶ˆé™¤åæƒ…ç»ª</button>
        </div>

        <!-- æ¸¸æˆåŒºåŸŸ -->
        <div class="game-area" id="gameArea">
            <p>è¯·é€‰æ‹©ä¸€ä¸ªæ¸¸æˆå¼€å§‹</p>
        </div>

        <!-- æ§åˆ¶æŒ‰é’® -->
        <div class="controls">
            <button class="btn btn-success" onclick="nextRound()">ä¸‹ä¸€é¢˜</button>
            <button class="btn" onclick="showManualJudgment()">æ‰‹åŠ¨åˆ¤æ–­</button>
            <button class="btn" onclick="exportData()">å¯¼å‡ºæ•°æ®</button>
            <button class="btn btn-danger" onclick="resetGame()">é‡æ–°å¼€å§‹</button>
        </div>

        <!-- åˆ†æ•°æ˜¾ç¤º -->
        <div class="score">
            å¾—åˆ†: <span id="score">0</span>
        </div>
    </div>

    <script>
        // æƒ…ç»ªåº“
        const emotions = ['é«˜å…´', 'ä¼¤å¿ƒ', 'æƒŠè®¶', 'ç”Ÿæ°”', 'åŒæ¶', 'ææƒ§'];
        const emotionIcons = {
            'é«˜å…´': 'ğŸ˜Š',
            'ä¼¤å¿ƒ': 'ğŸ˜¢', 
            'æƒŠè®¶': 'ğŸ˜²',
            'ç”Ÿæ°”': 'ğŸ˜ ',
            'åŒæ¶': 'ğŸ¤¢',
            'ææƒ§': 'ğŸ˜¨'
        };

        // è´Ÿé¢æƒ…ç»ªï¼ˆç”¨äºæ¶ˆé™¤æ¸¸æˆï¼‰
        const negativeEmotions = ['ç”Ÿæ°”', 'ä¼¤å¿ƒ', 'åŒæ¶', 'ææƒ§'];

        // æƒ…å¢ƒåº“
        const situations = [
            { situation: "æ”¶åˆ°ç”Ÿæ—¥ç¤¼ç‰©", emotion: "é«˜å…´" },
            { situation: "ç©å…·è¢«å¼„åäº†", emotion: "ä¼¤å¿ƒ" },
            { situation: "çªç„¶å¬åˆ°å·¨å“", emotion: "æƒŠè®¶" },
            { situation: "è¢«åŒå­¦æ¨äº†ä¸€ä¸‹", emotion: "ç”Ÿæ°”" },
            { situation: "é—»åˆ°éš¾é—»æ°”å‘³", emotion: "åŒæ¶" },
            { situation: "åœ¨é»‘æš—ä¸­ç‹¬å¤„", emotion: "ææƒ§" }
        ];

        // æ¸¸æˆçŠ¶æ€
        let currentGame = null;
        let currentTarget = null;
        let score = 0;
        let gameData = [];

        // å¼€å§‹æ¸¸æˆ
        function startGame(gameType) {
            currentGame = gameType;
            resetGameArea();
            
            switch(gameType) {
                case 'identification':
                    startIdentificationGame();
                    break;
                case 'matching':
                    startMatchingGame();
                    break;
                case 'situation':
                    startSituationGame();
                    break;
                case 'eliminate':
                    startEliminateGame();
                    break;
            }
        }

        // æƒ…ç»ªæŒ‡è®¤æ¸¸æˆ
        function startIdentificationGame() {
            // éšæœºé€‰æ‹©ç›®æ ‡æƒ…ç»ª
            currentTarget = emotions[Math.floor(Math.random() * emotions.length)];
            
            // åˆ›å»ºé€‰é¡¹ï¼ˆåŒ…å«æ­£ç¡®ç­”æ¡ˆå’Œ3ä¸ªé”™è¯¯ç­”æ¡ˆï¼‰
            let options = [currentTarget];
            while (options.length < 4) {
                const randomEmotion = emotions[Math.floor(Math.random() * emotions.length)];
                if (!options.includes(randomEmotion)) {
                    options.push(randomEmotion);
                }
            }
            
            // æ‰“ä¹±é€‰é¡¹é¡ºåº
            options = shuffleArray(options);
            
            // æ›´æ–°ç•Œé¢
            const gameArea = document.getElementById('gameArea');
            gameArea.innerHTML = `
                <div class="target">è¯·è¯†åˆ«è¿™ä¸ªæƒ…ç»ª: ${emotionIcons[currentTarget]}</div>
                <div class="options" id="optionsContainer"></div>
            `;
            
            const optionsContainer = document.getElementById('optionsContainer');
            options.forEach(emotion => {
                const option = document.createElement('div');
                option.className = 'option';
                option.textContent = emotion;
                option.onclick = () => checkAnswer(emotion);
                optionsContainer.appendChild(option);
            });
        }

        // æƒ…ç»ªé…å¯¹æ¸¸æˆ
        function startMatchingGame() {
            // éšæœºé€‰æ‹©ç›®æ ‡æƒ…ç»ª
            currentTarget = emotions[Math.floor(Math.random() * emotions.length)];
            
            // åˆ›å»ºé€‰é¡¹ï¼ˆåŒ…å«3ä¸ªç›¸åŒæƒ…ç»ªçš„ä¸åŒemojiå’Œ1ä¸ªä¸åŒæƒ…ç»ªï¼‰
            let options = [
                { emotion: currentTarget, icon: emotionIcons[currentTarget] },
                { emotion: currentTarget, icon: getSimilarEmoji(currentTarget) },
                { emotion: currentTarget, icon: getSimilarEmoji(currentTarget) }
            ];
            
            // æ·»åŠ ä¸€ä¸ªä¸åŒæƒ…ç»ªçš„é€‰é¡¹
            let differentEmotion;
            do {
                differentEmotion = emotions[Math.floor(Math.random() * emotions.length)];
            } while (differentEmotion === currentTarget);
            
            options.push({ emotion: differentEmotion, icon: emotionIcons[differentEmotion] });
            
            // æ‰“ä¹±é€‰é¡¹é¡ºåº
            options = shuffleArray(options);
            
            // æ›´æ–°ç•Œé¢
            const gameArea = document.getElementById('gameArea');
            gameArea.innerHTML = `
                <div class="target">è¯·æ‰¾å‡ºæ‰€æœ‰${currentTarget}çš„è¡¨æƒ…</div>
                <div class="options" id="optionsContainer"></div>
            `;
            
            const optionsContainer = document.getElementById('optionsContainer');
            options.forEach(item => {
                const option = document.createElement('div');
                option.className = 'option';
                option.innerHTML = item.icon;
                option.onclick = () => checkMatchingAnswer(item.emotion === currentTarget);
                optionsContainer.appendChild(option);
            });
        }

        // æƒ…å¢ƒé…å¯¹æ¸¸æˆ
        function startSituationGame() {
            // éšæœºé€‰æ‹©æƒ…å¢ƒ
            const situation = situations[Math.floor(Math.random() * situations.length)];
            currentTarget = situation.emotion;
            
            // åˆ›å»ºé€‰é¡¹ï¼ˆåŒ…å«æ­£ç¡®ç­”æ¡ˆå’Œ3ä¸ªé”™è¯¯ç­”æ¡ˆï¼‰
            let options = [situation.emotion];
            while (options.length < 4) {
                const randomEmotion = emotions[Math.floor(Math.random() * emotions.length)];
                if (!options.includes(randomEmotion)) {
                    options.push(randomEmotion);
                }
            }
            
            // æ‰“ä¹±é€‰é¡¹é¡ºåº
            options = shuffleArray(options);
            
            // æ›´æ–°ç•Œé¢
            const gameArea = document.getElementById('gameArea');
            gameArea.innerHTML = `
                <div class="target">${situation.situation}ï¼Œåº”è¯¥æ˜¯ä»€ä¹ˆæƒ…ç»ªï¼Ÿ</div>
                <div class="options" id="optionsContainer"></div>
            `;
            
            const optionsContainer = document.getElementById('optionsContainer');
            options.forEach(emotion => {
                const option = document.createElement('div');
                option.className = 'option';
                option.innerHTML = `${emotion} ${emotionIcons[emotion]}`;
                option.onclick = () => checkAnswer(emotion);
                optionsContainer.appendChild(option);
            });
        }

        // æ¶ˆé™¤åæƒ…ç»ªæ¸¸æˆ
        function startEliminateGame() {
            // åˆ›å»ºæƒ…ç»ªæ³¡æ³¡ï¼ˆæ··åˆæ­£é¢å’Œè´Ÿé¢æƒ…ç»ªï¼‰
            let emotionBubbles = [];
            
            // æ·»åŠ 2-3ä¸ªè´Ÿé¢æƒ…ç»ª
            const numNegative = Math.floor(Math.random() * 2) + 2;
            for (let i = 0; i < numNegative; i++) {
                const emotion = negativeEmotions[Math.floor(Math.random() * negativeEmotions.length)];
                emotionBubbles.push({ emotion, isNegative: true });
            }
            
            // æ·»åŠ 2-3ä¸ªæ­£é¢æƒ…ç»ª
            const positiveEmotions = ['é«˜å…´', 'æƒŠè®¶'];
            const numPositive = Math.floor(Math.random() * 2) + 2;
            for (let i = 0; i < numPositive; i++) {
                const emotion = positiveEmotions[Math.floor(Math.random() * positiveEmotions.length)];
                emotionBubbles.push({ emotion, isNegative: false });
            }
            
            // æ‰“ä¹±é¡ºåº
            emotionBubbles = shuffleArray(emotionBubbles);
            
            // æ›´æ–°ç•Œé¢
            const gameArea = document.getElementById('gameArea');
            gameArea.innerHTML = `
                <div class="target">è¯·ç‚¹å‡»æ¶ˆé™¤æ‰€æœ‰è´Ÿé¢æƒ…ç»ªï¼ˆç”Ÿæ°”ã€ä¼¤å¿ƒã€åŒæ¶ã€ææƒ§ï¼‰</div>
                <div class="options" id="optionsContainer"></div>
            `;
            
            const optionsContainer = document.getElementById('optionsContainer');
            emotionBubbles.forEach(bubble => {
                const option = document.createElement('div');
                option.className = 'option';
                option.innerHTML = emotionIcons[bubble.emotion];
                option.dataset.emotion = bubble.emotion;
                option.dataset.isNegative = bubble.isNegative;
                option.onclick = function() {
                    checkEliminateAnswer(this);
                };
                optionsContainer.appendChild(option);
            });
            
            // é‡ç½®å½“å‰ç›®æ ‡ï¼ˆè¿™ä¸ªæ¸¸æˆæ²¡æœ‰å•ä¸€ç›®æ ‡ï¼‰
            currentTarget = null;
        }

        // æ£€æŸ¥ç­”æ¡ˆï¼ˆé€šç”¨ï¼‰
        function checkAnswer(selectedEmotion) {
            const isCorrect = selectedEmotion === currentTarget;
            
            // è®°å½•ç»“æœ
            gameData.push({
                game: currentGame,
                target: currentTarget,
                selected: selectedEmotion,
                correct: isCorrect,
                timestamp: new Date().toISOString()
            });
            
            // æ˜¾ç¤ºåé¦ˆ
            showFeedback(isCorrect, isCorrect ? 
                `å¤ªæ£’äº†ï¼ç­”å¯¹äº†ï¼è¿™æ˜¯${currentTarget}` : 
                `ä¸å¯¹å“¦ï¼Œè¿™æ˜¯${currentTarget}`);
            
            // æ›´æ–°åˆ†æ•°
            if (isCorrect) {
                score += 10;
                document.getElementById('score').textContent = score;
            }
        }

        // æ£€æŸ¥é…å¯¹ç­”æ¡ˆ
        function checkMatchingAnswer(isCorrect) {
            // è®°å½•ç»“æœ
            gameData.push({
                game: currentGame,
                target: currentTarget,
                selected: isCorrect ? "æ­£ç¡®é…å¯¹" : "é”™è¯¯é…å¯¹",
                correct: isCorrect,
                timestamp: new Date().toISOString()
            });
            
            // æ˜¾ç¤ºåé¦ˆ
            showFeedback(isCorrect, isCorrect ? 
                `å¤ªæ£’äº†ï¼è¿™æ˜¯${currentTarget}çš„è¡¨æƒ…` : 
                `ä¸å¯¹å“¦ï¼Œè¿™ä¸æ˜¯${currentTarget}çš„è¡¨æƒ…`);
            
            // æ›´æ–°åˆ†æ•°
            if (isCorrect) {
                score += 10;
                document.getElementById('score').textContent = score;
            }
        }

        // æ£€æŸ¥æ¶ˆé™¤æ¸¸æˆç­”æ¡ˆ
        function checkEliminateAnswer(element) {
            const isNegative = element.dataset.isNegative === 'true';
            const emotion = element.dataset.emotion;
            
            // è®°å½•ç»“æœ
            gameData.push({
                game: currentGame,
                target: "æ¶ˆé™¤è´Ÿé¢æƒ…ç»ª",
                selected: emotion,
                correct: isNegative,
                timestamp: new Date().toISOString()
            });
            
            if (isNegative) {
                // æ­£ç¡®æ¶ˆé™¤è´Ÿé¢æƒ…ç»ª
                element.style.opacity = '0.3';
                element.style.transform = 'scale(0.8)';
                element.onclick = null; // é˜²æ­¢é‡å¤ç‚¹å‡»
                
                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰è´Ÿé¢æƒ…ç»ªéƒ½å·²æ¶ˆé™¤
                const remainingNegative = document.querySelectorAll('.option[data-is-negative="true"]:not([style*="opacity: 0.3"])');
                if (remainingNegative.length === 0) {
                    showFeedback(true, "å¤ªæ£’äº†ï¼æ‰€æœ‰è´Ÿé¢æƒ…ç»ªéƒ½å·²æ¶ˆé™¤ï¼");
                    score += 15;
                    document.getElementById('score').textContent = score;
                }
            } else {
                // é”™è¯¯æ¶ˆé™¤æ­£é¢æƒ…ç»ª
                showFeedback(false, `è¿™æ˜¯${emotion}ï¼Œæ˜¯æ­£é¢æƒ…ç»ªï¼Œä¸éœ€è¦æ¶ˆé™¤`);
            }
        }

        // æ˜¾ç¤ºåé¦ˆ
        function showFeedback(isSuccess, message) {
            // ç§»é™¤ä¹‹å‰çš„åé¦ˆ
            const oldFeedback = document.querySelector('.feedback');
            if (oldFeedback) {
                oldFeedback.remove();
            }
            
            // åˆ›å»ºæ–°åé¦ˆ
            const feedback = document.createElement('div');
            feedback.className = `feedback ${isSuccess ? 'success' : 'error'}`;
            feedback.textContent = message;
            
            document.getElementById('gameArea').appendChild(feedback);
            feedback.style.display = 'block';
        }

        // ä¸‹ä¸€é¢˜
        function nextRound() {
            if (currentGame) {
                startGame(currentGame);
            }
        }

        // æ‰‹åŠ¨åˆ¤æ–­
        function showManualJudgment() {
            if (!currentGame || !currentTarget) {
                alert("è¯·å…ˆå¼€å§‹ä¸€ä¸ªæ¸¸æˆ");
                return;
            }
            
            const manualChoice = prompt(`è¯·æ‰‹åŠ¨åˆ¤æ–­æ­£ç¡®æƒ…ç»ªï¼ˆå½“å‰ç›®æ ‡: ${currentTarget}ï¼‰:\n${emotions.join(', ')}`);
            if (manualChoice && emotions.includes(manualChoice)) {
                checkAnswer(manualChoice);
            } else if (manualChoice) {
                alert("è¯·è¾“å…¥æœ‰æ•ˆçš„æƒ…ç»ªåç§°");
            }
        }

        // å¯¼å‡ºæ•°æ®
        function exportData() {
            if (gameData.length === 0) {
                alert("è¿˜æ²¡æœ‰æ¸¸æˆæ•°æ®å¯ä»¥å¯¼å‡º");
                return;
            }
            
            let csvContent = "æ—¶é—´,æ¸¸æˆç±»å‹,ç›®æ ‡æƒ…ç»ª,é€‰æ‹©æƒ…ç»ª,æ˜¯å¦æ­£ç¡®\n";
            gameData.forEach(record => {
                csvContent += `"${record.timestamp}","${record.game}","${record.target}","${record.selected}","${record.correct ? 'æ˜¯' : 'å¦'}"\n`;
            });
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            link.setAttribute("download", `æƒ…ç»ªæ¸¸æˆæ•°æ®_${new Date().getTime()}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // é‡ç½®æ¸¸æˆ
        function resetGame() {
            currentGame = null;
            currentTarget = null;
            score = 0;
            gameData = [];
            document.getElementById('score').textContent = '0';
            resetGameArea();
        }

        // é‡ç½®æ¸¸æˆåŒºåŸŸ
        function resetGameArea() {
            document.getElementById('gameArea').innerHTML = '<p>è¯·é€‰æ‹©ä¸€ä¸ªæ¸¸æˆå¼€å§‹</p>';
        }

        // å·¥å…·å‡½æ•°
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function getSimilarEmoji(emotion) {
            // è¿”å›ç›¸åŒæƒ…ç»ªçš„ä¸åŒemojiè¡¨ç¤º
            const variations = {
                'é«˜å…´': ['ğŸ˜„', 'ğŸ˜ƒ', 'ğŸ˜€', 'ğŸ˜Š', 'ğŸ˜'],
                'ä¼¤å¿ƒ': ['ğŸ˜¢', 'ğŸ˜­', 'ğŸ˜”', 'ğŸ˜', 'ğŸ˜¥'],
                'æƒŠè®¶': ['ğŸ˜²', 'ğŸ˜®', 'ğŸ˜¯', 'ğŸ™€', 'ğŸ˜§'],
                'ç”Ÿæ°”': ['ğŸ˜ ', 'ğŸ˜¡', 'ğŸ‘¿', 'ğŸ’¢', 'ğŸ˜¤'],
                'åŒæ¶': ['ğŸ¤¢', 'ğŸ¤®', 'ğŸ˜·', 'ğŸ˜–', 'ğŸ˜£'],
                'ææƒ§': ['ğŸ˜¨', 'ğŸ˜°', 'ğŸ˜±', 'ğŸ™€', 'ğŸ˜¬']
            };
            
            const options = variations[emotion] || [emotionIcons[emotion]];
            return options[Math.floor(Math.random() * options.length)];
        }
    </script>
</body>
</html>
